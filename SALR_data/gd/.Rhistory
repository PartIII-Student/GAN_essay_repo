which.median = function(x) {
if (length(x) %% 2 != 0) {
which(x == median(x))
} else if (length(x) %% 2 == 0) {
a = sort(x)[c(length(x)/2, length(x)/2+1)]
which(x == a[1])
}
}
median_of_third_col = function(df){
return(which.median(df[,3]))
}
median_row_indexes = lapply(KL_split,median_of_third_col)
if(plot_med_histogram_KL){
med_hist_data = list()
for(i in 1:9){
med_hist_data[[i]] = as.numeric(collected_split[[i]][median_row_indexes[[i]],3:ncol(collected_split[[i]])])
}
for(i in 1:9){
name = paste('p',i,sep = '')
assign(name,plot_individual_hist(med_hist_data[[i]], titles[[i]],theme_choice = export_theme))
}
for(i in 1:9){
name = paste('q',i,sep = '')
assign(name,plot_individual_hist(med_hist_data[[i]], titles[[i]],theme_choice = rstudio_theme))
}
jpeg(save_picture_name('med_histograms_KL'), units="in", width=16, height=12, res=300)
multiplot(p1, p2, p3, p4, p5, p6, p7, p8,p9, cols=3)
dev.off()
# multiplot(q1, q2, q3, q4, q5, q6, q7, q8,q9, cols=3)
}
# Median QQ plot -------
if(qqplot_median){
med_qq_data = list()
for(i in 1:9){
med_qq_data[[i]] = as.numeric(standardized_split[[i]][median_row_indexes[[i]],3:ncol(standardized_split[[i]])])
}
for(i in 1:9){
name = paste('p',i,sep = '')
assign(name,qqplot_individual(med_qq_data[[i]], titles[[i]],xlab ='',ylab = '',theme_choice = export_theme))
}
for(i in 1:9){
name = paste('q',i,sep = '')
assign(name,qqplot_individual(med_qq_data[[i]], titles[[i]],xlab ='',ylab = '',theme_choice = rstudio_theme))
}
jpeg(save_picture_name('QQplot_med'), units="in", width=16, height=12, res=300)
multiplot_QQ(p1, p2, p3, p4, p5, p6, p7, p8,p9, cols=3)
dev.off()
# multiplot_QQ(q1, q2, q3, q4, q5, q6, q7, q8,q9, cols=3)
}
# Overall median hist ----
median_row = as.numeric(collected_data[which.median(KL_dataframe[,3]),
3:ncol(collected_data)])
jpeg(save_picture_name('overall_median_hist'), units="in", width=10, height=7, res=300)
plot_individual_hist(median_row, max_density = 0.5, theme_choice = export_theme)
dev.off()
# Just phi = 0 hist ----
which.percentile = function(x, perc) {
if(perc>1){
perc = perc/100
}
index = as.integer(length(x)*perc)
percentile = sort(x)[index]
return(which(percentile == x))
}
median_row_phi_0 = as.numeric(collected_data[which.percentile(KL_dataframe[KL_dataframe$Phi == 0,3], 0.5),
3:ncol(collected_data)])
jpeg(save_picture_name('hist_phi_0'), units="in", width=10, height=7, res=300)
plot_individual_hist(median_row_phi_0, max_density = 0.5, theme_choice = export_theme)
dev.off()
# 9 random QQ plots ----
if(qqplot_randoms){
random_data = standardized_data[sample(1:nrow(standardized_data),size = 9, replace = F),]
titles = list()
for(i in 1:9){
titles[[i]] = bquote(gamma~'='~.(random_data$Gamma[i])~', '
~phi~'='~.(random_data$Phi[i]))
}
for(i in 1:9){
name = paste('p',i,sep = '')
assign(name,qqplot_individual(as.numeric(random_data[i,3:ncol(random_data)])
, titles[[i]],xlab ='',ylab = '',theme_choice = export_theme))
}
jpeg(save_picture_name('QQplot_random'), units="in", width=16, height=12, res=300)
multiplot_QQ(p1, p2, p3, p4, p5, p6, p7, p8,p9, cols=3)
dev.off()
# multiplot_QQ(q1, q2, q3, q4, q5, q6, q7, q8,q9, cols=3)
}
# find high and low points of smoothed surface ----
size_of_grid = 80
span1 = 0.5
fit_loess = loess(KL_real_gen~Gamma*Phi,data =KL_dataframe, span = span1)
g_p_grid = expand.grid(list(Gamma = seq(min(KL_dataframe$Gamma), max(KL_dataframe$Phi),
length.out = size_of_grid),
Phi = seq(min(KL_dataframe$Gamma),  max(KL_dataframe$Phi),
length.out = size_of_grid)))
predicted_KL = predict(fit_loess, newdata = g_p_grid)
predicted_KL1 = melt(predicted_KL)
predicted_KL1$Gamma = sapply(predicted_KL1$Gamma,function(x) as.numeric(gsub("Gamma=", "", x)))
predicted_KL1$Phi = sapply(predicted_KL1$Phi,function(x) as.numeric(gsub("Phi=", "", x)))
predicted_KL1 = na.omit(predicted_KL1)
best_phi = predicted_KL1[which.min(predicted_KL1[,3]),2]
worst_phi = predicted_KL1[which.max(predicted_KL1[,3]),2]
band_half_size = 0.001
best_band = KL_dataframe[KL_dataframe$Phi > best_phi - band_half_size &
KL_dataframe$Phi < best_phi + band_half_size, ]
worst_band = KL_dataframe[KL_dataframe$Phi > worst_phi - band_half_size &
KL_dataframe$Phi < worst_phi + band_half_size, ]
all_data_to_plot  = data.frame(Gamma = best_band[,1], variable = replicate(nrow(best_band),'Best')
, value =best_band[,3])
all_data_to_plot = rbind(all_data_to_plot, data.frame(Gamma = worst_band[,1],
variable = replicate(nrow(worst_band),'Worst')
, value =worst_band[,3]))
names = c('SGD', 'Adam','Momentum')
for(i in 1:3){
dat = kl_controls[[i]]
all_data_to_plot = rbind(all_data_to_plot, data.frame(Gamma = dat[,1],
variable = replicate(nrow(dat),
names[i])
, value =dat[,3]))
}
best_title = bquote('Score Adaptive,'~phi %~~% .(round(best_phi,2)))
worst_title = bquote('Score Adaptive, '~phi %~~% .(round(worst_phi,2)))
gamma_title = bquote(gamma)
export_theme2 = theme(text=element_text(size=20),
axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)),
axis.title.x = element_text(margin = margin(t = 20, r = 0, b = 0, l = 0)),
legend.key.size = unit(2, 'lines'))
jpeg(save_picture_name('compare_algos'), units="in", width=13, height=8, res=300)
ggplot(all_data_to_plot,aes(x = Gamma, y = value, colour =variable )) +
geom_smooth(aes(colour = variable),se = F)+
ylab('Estimated KL Divergence')+
xlab(gamma_title)+ export_theme2+
ggtitle('Estimated KL Divergence for Various Optimization Algorithms')+
scale_colour_discrete(name = 'Algorithm',
breaks = c('Best','Worst','SGD','Adam','Momentum'),
labels = c(best_title,worst_title,'SGD','Adam','Momentum'))
dev.off()
ggplot(all_data_to_plot,aes(x = Gamma, y = value, colour =variable )) +
geom_smooth(aes(colour = variable),se = F)+
ylab('Estimated KL Divergence')+
xlab(gamma_title)+
ggtitle('Estimated KL Divergence for Various Optimization Algorithms')+
scale_colour_discrete(name = 'Algorithm',
breaks = c('Best','Worst','SGD','Adam','Momentum'),
labels = c(best_title,worst_title,'SGD','Adam','Momentum'))
RESET = F
doc = '/Users/Billy/Documents/Uni/cam/theorem_gen/MSM.txt'
nrow = 40
if(RESET){
new = matrix(nrow = nrow, ncol =  3)
colnames(new) = c('Theorem', 'Times Complete','Happy')
new[,1] = 1:40
new[,2] = replicate(nrow,1)
new[,3] = replicate(nrow,0)
write.table(new,doc)
}
dat = read.table(doc)
dat = dat[!dat[,3] ==1,]
select_row = sample(1:nrow,1,prob = 1/dat[,2]^2)
dat[select_row,2] = dat[select_row,2]+1
write.table(dat,doc)
dat[select_row,1:2]
# Remove the plus 1 if not clear:
not_clear = F
if(not_clear){
dat[select_row,2] = dat[select_row,2]-1
write.table(dat,doc)
}
size_of_grid = 80
span1 = 0.05
fit_loess = loess(KL_real_gen~Gamma*Phi,data =KL_dataframe, span = span1)
g_p_grid = expand.grid(list(Gamma = seq(min(KL_dataframe$Gamma), max(KL_dataframe$Phi),
length.out = size_of_grid),
Phi = seq(min(KL_dataframe$Gamma),  max(KL_dataframe$Phi),
length.out = size_of_grid)))
predicted_KL = predict(fit_loess, newdata = g_p_grid)
predicted_KL1 = melt(predicted_KL)
predicted_KL1$Gamma = sapply(predicted_KL1$Gamma,function(x) as.numeric(gsub("Gamma=", "", x)))
predicted_KL1$Phi = sapply(predicted_KL1$Phi,function(x) as.numeric(gsub("Phi=", "", x)))
predicted_KL1 = na.omit(predicted_KL1)
best_phi = predicted_KL1[which.min(predicted_KL1[,3]),2]
worst_phi = predicted_KL1[which.max(predicted_KL1[,3]),2]
band_half_size = 0.001
best_band = KL_dataframe[KL_dataframe$Phi > best_phi - band_half_size &
KL_dataframe$Phi < best_phi + band_half_size, ]
worst_band = KL_dataframe[KL_dataframe$Phi > worst_phi - band_half_size &
KL_dataframe$Phi < worst_phi + band_half_size, ]
all_data_to_plot  = data.frame(Gamma = best_band[,1], variable = replicate(nrow(best_band),'Best')
, value =best_band[,3])
all_data_to_plot = rbind(all_data_to_plot, data.frame(Gamma = worst_band[,1],
variable = replicate(nrow(worst_band),'Worst')
, value =worst_band[,3]))
names = c('SGD', 'Adam','Momentum')
for(i in 1:3){
dat = kl_controls[[i]]
all_data_to_plot = rbind(all_data_to_plot, data.frame(Gamma = dat[,1],
variable = replicate(nrow(dat),
names[i])
, value =dat[,3]))
}
best_title = bquote('Score Adaptive,'~phi %~~% .(round(best_phi,2)))
worst_title = bquote('Score Adaptive, '~phi %~~% .(round(worst_phi,2)))
gamma_title = bquote(gamma)
export_theme2 = theme(text=element_text(size=20),
axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)),
axis.title.x = element_text(margin = margin(t = 20, r = 0, b = 0, l = 0)),
legend.key.size = unit(2, 'lines'))
jpeg(save_picture_name('compare_algos'), units="in", width=13, height=8, res=300)
ggplot(all_data_to_plot,aes(x = Gamma, y = value, colour =variable )) +
geom_smooth(aes(colour = variable),se = F)+
ylab('Estimated KL Divergence')+
xlab(gamma_title)+ export_theme2+
ggtitle('Estimated KL Divergence for Various Optimization Algorithms')+
scale_colour_discrete(name = 'Algorithm',
breaks = c('Best','Worst','SGD','Adam','Momentum'),
labels = c(best_title,worst_title,'SGD','Adam','Momentum'))
dev.off()
ggplot(all_data_to_plot,aes(x = Gamma, y = value, colour =variable )) +
geom_smooth(aes(colour = variable),se = F)+
ylab('Estimated KL Divergence')+
xlab(gamma_title)+
ggtitle('Estimated KL Divergence for Various Optimization Algorithms')+
scale_colour_discrete(name = 'Algorithm',
breaks = c('Best','Worst','SGD','Adam','Momentum'),
labels = c(best_title,worst_title,'SGD','Adam','Momentum'))
size_of_grid = 80
span1 = 0.5
fit_loess = loess(KL_real_gen~Gamma*Phi,data =KL_dataframe, span = span1)
g_p_grid = expand.grid(list(Gamma = seq(min(KL_dataframe$Gamma), max(KL_dataframe$Phi),
length.out = size_of_grid),
Phi = seq(min(KL_dataframe$Gamma),  max(KL_dataframe$Phi),
length.out = size_of_grid)))
predicted_KL = predict(fit_loess, newdata = g_p_grid)
predicted_KL1 = melt(predicted_KL)
predicted_KL1$Gamma = sapply(predicted_KL1$Gamma,function(x) as.numeric(gsub("Gamma=", "", x)))
predicted_KL1$Phi = sapply(predicted_KL1$Phi,function(x) as.numeric(gsub("Phi=", "", x)))
predicted_KL1 = na.omit(predicted_KL1)
best_phi = predicted_KL1[which.min(predicted_KL1[,3]),2]
worst_phi = predicted_KL1[which.max(predicted_KL1[,3]),2]
band_half_size = 0.001
best_band = KL_dataframe[KL_dataframe$Phi > best_phi - band_half_size &
KL_dataframe$Phi < best_phi + band_half_size, ]
worst_band = KL_dataframe[KL_dataframe$Phi > worst_phi - band_half_size &
KL_dataframe$Phi < worst_phi + band_half_size, ]
all_data_to_plot  = data.frame(Gamma = best_band[,1], variable = replicate(nrow(best_band),'Best')
, value =best_band[,3])
all_data_to_plot = rbind(all_data_to_plot, data.frame(Gamma = worst_band[,1],
variable = replicate(nrow(worst_band),'Worst')
, value =worst_band[,3]))
names = c('SGD', 'Adam','Momentum')
for(i in 1:3){
dat = kl_controls[[i]]
all_data_to_plot = rbind(all_data_to_plot, data.frame(Gamma = dat[,1],
variable = replicate(nrow(dat),
names[i])
, value =dat[,3]))
}
best_title = bquote('Score Adaptive,'~phi %~~% .(round(best_phi,2)))
worst_title = bquote('Score Adaptive, '~phi %~~% .(round(worst_phi,2)))
gamma_title = bquote(gamma)
export_theme2 = theme(text=element_text(size=20),
axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)),
axis.title.x = element_text(margin = margin(t = 20, r = 0, b = 0, l = 0)),
legend.key.size = unit(2, 'lines'))
jpeg(save_picture_name('compare_algos'), units="in", width=13, height=8, res=300)
ggplot(all_data_to_plot,aes(x = Gamma, y = value, colour =variable )) +
geom_smooth(aes(colour = variable),se = F)+
ylab('Estimated KL Divergence')+
xlab(gamma_title)+ export_theme2+
ggtitle('Estimated KL Divergence for Various Optimization Algorithms')+
scale_colour_discrete(name = 'Algorithm',
breaks = c('Best','Worst','SGD','Adam','Momentum'),
labels = c(best_title,worst_title,'SGD','Adam','Momentum'))
dev.off()
ggplot(all_data_to_plot,aes(x = Gamma, y = value, colour =variable )) +
geom_smooth(aes(colour = variable),se = F)+
ylab('Estimated KL Divergence')+
xlab(gamma_title)+
ggtitle('Estimated KL Divergence for Various Optimization Algorithms')+
scale_colour_discrete(name = 'Algorithm',
breaks = c('Best','Worst','SGD','Adam','Momentum'),
labels = c(best_title,worst_title,'SGD','Adam','Momentum'))
ggplot(all_data_to_plot,aes(x = Gamma, y = value, colour =variable )) +
geom_smooth(aes(colour = variable),method = 'loess',se = F)+
ylab('Estimated KL Divergence')+
xlab(gamma_title)+
ggtitle('Estimated KL Divergence for Various Optimization Algorithms')+
scale_colour_discrete(name = 'Algorithm',
breaks = c('Best','Worst','SGD','Adam','Momentum'),
labels = c(best_title,worst_title,'SGD','Adam','Momentum'))
RESET = F
doc = '/Users/Billy/Documents/Uni/cam/theorem_gen/MSM.txt'
nrow = 40
if(RESET){
new = matrix(nrow = nrow, ncol =  3)
colnames(new) = c('Theorem', 'Times Complete','Happy')
new[,1] = 1:40
new[,2] = replicate(nrow,1)
new[,3] = replicate(nrow,0)
write.table(new,doc)
}
dat = read.table(doc)
dat = dat[!dat[,3] ==1,]
select_row = sample(1:nrow,1,prob = 1/dat[,2]^2)
dat[select_row,2] = dat[select_row,2]+1
write.table(dat,doc)
dat[select_row,1:2]
# Remove the plus 1 if not clear:
not_clear = F
if(not_clear){
dat[select_row,2] = dat[select_row,2]-1
write.table(dat,doc)
}
not_clear = T
if(not_clear){
dat[select_row,2] = dat[select_row,2]-1
write.table(dat,doc)
}
RESET = F
doc = '/Users/Billy/Documents/Uni/cam/theorem_gen/MSM.txt'
nrow = 40
if(RESET){
new = matrix(nrow = nrow, ncol =  3)
colnames(new) = c('Theorem', 'Times Complete','Happy')
new[,1] = 1:40
new[,2] = replicate(nrow,1)
new[,3] = replicate(nrow,0)
write.table(new,doc)
}
dat = read.table(doc)
dat = dat[!dat[,3] ==1,]
select_row = sample(1:nrow,1,prob = 1/dat[,2]^2)
dat[select_row,2] = dat[select_row,2]+1
write.table(dat,doc)
dat[select_row,1:2]
# Remove the plus 1 if not clear:
not_clear = F
if(not_clear){
dat[select_row,2] = dat[select_row,2]-1
write.table(dat,doc)
}
RESET = F
doc = '/Users/Billy/Documents/Uni/cam/theorem_gen/MSM.txt'
nrow = 40
if(RESET){
new = matrix(nrow = nrow, ncol =  3)
colnames(new) = c('Theorem', 'Times Complete','Happy')
new[,1] = 1:40
new[,2] = replicate(nrow,1)
new[,3] = replicate(nrow,0)
write.table(new,doc)
}
dat = read.table(doc)
dat = dat[!dat[,3] ==1,]
select_row = sample(1:nrow,1,prob = 1/dat[,2]^2)
dat[select_row,2] = dat[select_row,2]+1
write.table(dat,doc)
dat[select_row,1:2]
# Remove the plus 1 if not clear:
not_clear = F
if(not_clear){
dat[select_row,2] = dat[select_row,2]-1
write.table(dat,doc)
}
RESET = F
doc = '/Users/Billy/Documents/Uni/cam/theorem_gen/MSM.txt'
nrow = 40
if(RESET){
new = matrix(nrow = nrow, ncol =  3)
colnames(new) = c('Theorem', 'Times Complete','Happy')
new[,1] = 1:40
new[,2] = replicate(nrow,1)
new[,3] = replicate(nrow,0)
write.table(new,doc)
}
dat = read.table(doc)
dat = dat[!dat[,3] ==1,]
select_row = sample(1:nrow,1,prob = 1/dat[,2]^2)
dat[select_row,2] = dat[select_row,2]+1
write.table(dat,doc)
dat[select_row,1:2]
# Remove the plus 1 if not clear:
not_clear = F
if(not_clear){
dat[select_row,2] = dat[select_row,2]-1
write.table(dat,doc)
}
# Packages ##################################################
rm(list = ls(all=T))
suppressMessages(suppressWarnings(library(reshape2)))
library(plyr)
suppressMessages(suppressWarnings(library(ggplot2)))
library(scatterplot3d)
suppressMessages(suppressWarnings(library(data.table)))
suppressMessages(suppressWarnings(library(plotly)))
library(lattice)
library(FNN)
library(pbapply)
library('grDevices')
library(dplyr)
source('/Users/Billy/PycharmProjects/GALR/mulitplot.R')
# Which plots to show ##################################################
phi_against_gamma = T
loess_plot_KL = T
plot_best_histogram_KL = T
qqplot = T
plot_med_histogram_KL = T
qqplot_median = T
qqplot_randoms = T
recalc_KL = T
# Sub folder ##################################################
main_folder = 'data_uneven2'
sub_folder = 'gd'
save_picture_name = function(name){
dir = paste(c('/Users/Billy/Documents/Uni/cam/GAN/essay tex/plots_pictures/',main_folder,'_',sub_folder,'_',name,'.jpeg'),
collapse = '')
return(dir)
}
# Make colours and font size  ##################################################
gg_color_hue <- function(n) {
hues = seq(15, 375, length = n + 1)
hcl(h = hues, l = 65, c = 100)[1:n]
}
cols = gg_color_hue(2)
export_theme1 = theme(text=element_text(size=40),
axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)),
axis.title.x = element_text(margin = margin(t = 20, r = 0, b = 0, l = 0)))
export_theme = theme(text=element_text(size=20),
axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)),
axis.title.x = element_text(margin = margin(t = 20, r = 0, b = 0, l = 0)))
rstudio_theme = theme(text=element_text(size=8),
axis.title.y = element_text(margin = margin(t = 0, r = 20, b = 0, l = 0)),
axis.title.x = element_text(margin = margin(t = 20, r = 0, b = 0, l = 0)))
# Collect data ##################################################
data_path = paste0(c('/Users/Billy/PycharmProjects/GALR/',main_folder,'/',sub_folder), collapse='')
setwd(data_path)
collected_data = fread('output.csv', header = F, sep = ',')
collected_data = data.matrix(collected_data)
collected_data = na.omit(collected_data)
collected_data= data.frame(Gamma =collected_data[,1] ,
Phi= collected_data[,2] ,collected_data[,3:ncol(collected_data)])
standardized_data = collected_data
standardized_data[,3:ncol(standardized_data)] = standardized_data[,3:ncol(standardized_data)] -6
nrow(collected_data)
gamma_boundaries= c(min(collected_data$Gamma)+
(max(collected_data$Gamma)-min(collected_data$Gamma))/3 ,
min(collected_data$Gamma)+
2*(max(collected_data$Gamma)-min(collected_data$Gamma))/3)
phi_boundaries = c(min(collected_data$Phi),
min(collected_data$Phi)+
(max(collected_data$Phi)-min(collected_data$Phi))/2)
# Samples plot  ##################################################
if(phi_against_gamma){
cols = gg_color_hue(2)
p1 = ggplot(collected_data,aes(x = Gamma, y = Phi))+geom_point(col=cols[1])+
geom_hline(yintercept = phi_boundaries[1]+0.001, col=cols[2], lty = 2, lwd = 3) +
geom_hline(yintercept = phi_boundaries[2], col=cols[2], lty = 2, lwd = 3)+
geom_vline(xintercept = gamma_boundaries[1], col=cols[2], lty = 2, lwd = 3) +
geom_vline(xintercept = gamma_boundaries[2], col=cols[2], lty = 2, lwd = 3)+
xlab(bquote(gamma))+ylab(bquote(phi))+export_theme1
print(p1)
jpeg(save_picture_name('samples'), units="in", width=16, height=12, res=300)
print(p1)
dev.off()
}
# How many NaNs ----
means = rowMeans(collected_data[,3:ncol(collected_data)])
mean(means > 0 | means < 0)
# Calc KL Divergence and save to file -------
if(recalc_KL){
real_dist = rnorm(10000 , 6,1)
kl_to_real = function(vec){
vec_1 = as.numeric(vec)
return(KL.divergence(real_dist,vec_1,k=10)[10])
}
kl_from_real = function(vec){
vec_1 = as.numeric(vec)
return(KL.divergence(vec_1,real_dist,k=10)[10])
}
KL_vec = pbapply(collected_data[,3:ncol(collected_data)],MARGIN = 1,kl_to_real)
KL_vec2 = pbapply(collected_data[,3:ncol(collected_data)],MARGIN = 1,kl_from_real)
KL_dataframe <<- data.frame(Gamma = collected_data[,1],
Phi = collected_data[,2],
KL_real_gen = KL_vec,
KL_gen_real = KL_vec2)
write.csv(x = KL_dataframe, 'KL_divergence.csv',row.names = F)
} else{
KL_dataframe <<- read.csv('KL_divergence.csv', header=T)
}
RESET = F
doc = '/Users/Billy/Documents/Uni/cam/theorem_gen/MSM.txt'
nrow = 40
if(RESET){
new = matrix(nrow = nrow, ncol =  3)
colnames(new) = c('Theorem', 'Times Complete','Happy')
new[,1] = 1:40
new[,2] = replicate(nrow,1)
new[,3] = replicate(nrow,0)
write.table(new,doc)
}
dat = read.table(doc)
dat = dat[!dat[,3] ==1,]
select_row = sample(1:nrow,1,prob = 1/dat[,2]^2)
dat[select_row,2] = dat[select_row,2]+1
write.table(dat,doc)
dat[select_row,1:2]
# Remove the plus 1 if not clear:
not_clear = F
if(not_clear){
dat[select_row,2] = dat[select_row,2]-1
write.table(dat,doc)
}
